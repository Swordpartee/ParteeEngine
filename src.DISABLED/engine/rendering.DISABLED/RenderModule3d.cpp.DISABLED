// #include "engine//RenderModule3d.hpp"

// #include "engine/entities/components/RenderComponent.hpp"
// #include "engine/entities/components/TransformComponent.hpp"
// #include "engine/entities/Entity.hpp"

// #include <GL/gl.h>
// #include <windows.h>
// #include <cmath>
// #include <algorithm>

namespace ParteeEngine {

    bool RenderModule3d::initialize(const ModuleInputs &inputs) {
        window.show();

        PIXELFORMATDESCRIPTOR pfd = {
            sizeof(PIXELFORMATDESCRIPTOR),
            1,
            PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
            PFD_TYPE_RGBA,
            32, // Color depth
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            24, // Depth buffer
            8,  // Stencil buffer
            0, PFD_MAIN_PLANE, 0, 0, 0, 0};

        HDC hdc = window.getHDC();
        int pixelFormat = ChoosePixelFormat(hdc, &pfd);
        SetPixelFormat(hdc, pixelFormat, &pfd);

        HGLRC hglrc = wglCreateContext(hdc);
        wglMakeCurrent(hdc, hglrc);

        // Setup viewport
        RECT rect;
        GetClientRect(window.getHWND(), &rect);
        glViewport(0, 0, rect.right, rect.bottom);

        // Setup 3D perspective projection
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        
        float aspect = (float)rect.right / (float)rect.bottom;
        float fov = 120.0f; // Field of view in degrees
        float nearPlane = 0.1f;
        float farPlane = 1000.0f;
        
        // Manual perspective projection matrix
        float f = 1.0f / std::tan((fov * 3.14159f / 180.0f) / 2.0f);
        float rangeInv = 1.0f / (nearPlane - farPlane);
        
        float perspectiveMatrix[16] = {
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (nearPlane + farPlane) * rangeInv, -1,
            0, 0, nearPlane * farPlane * rangeInv * 2.0f, 0
        };
        
        glMultMatrixf(perspectiveMatrix);
        
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();

        // Enable 3D rendering features
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_LINE_SMOOTH);
        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
        return true;
        
    }

    bool RenderModule3d::update(const ModuleUpdateInputs &inputs) {
        if (!window.processMessages()) {
            return false;
        }

        // Clear screen and depth buffer
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glClearColor(0.1f, 0.1f, 0.15f, 1.0f);

        // Setup camera
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        // Position camera looking at the scene (negate Y to flip upside down)
        glScalef(1.0f, -1.0f, 1.0f);
        glTranslatef(0.0f, 0.0f, -800.0f);

        // Render each entity as a 3D cube
        for (const auto &entity : inputs.entities)
        {
            auto *renderComp = entity.getComponent<RenderComponent>();
            if (!renderComp) continue;

            auto *transformComp = entity.getComponent<TransformComponent>();
            if (!transformComp) continue;
            
            const Vector3 &position = transformComp->getPosition();
            const Vector3 &normal = transformComp->getRotation();
            const Vector3 &scale = transformComp->getScale();
            
            float halfWidth = scale.x * 0.5f;
            float halfHeight = scale.y * 0.5f;
            float halfDepth = scale.z * 0.5f;
            
            Vector3 normalizedNormal = normal.normalize();
            Vector3 defaultForward(0.0f, 0.0f, 1.0f);
            Vector3 rotAxis = defaultForward.cross(normalizedNormal);
            float rotAxisLen = rotAxis.length();
            
            glPushMatrix();
            
            // Translate to position
            glTranslatef(position.x, position.y, position.z);
            
            // Apply rotation
            if (rotAxisLen > 0.001f) {
                float dotProduct = defaultForward.dot(normalizedNormal);
                dotProduct = std::clamp(dotProduct, -1.0f, 1.0f);
                float angle = std::acos(dotProduct) * 180.0f / 3.14159265f;
                rotAxis = rotAxis.normalize();
                glRotatef(angle, rotAxis.x, rotAxis.y, rotAxis.z);
            }

            // Draw 3D cube with 6 faces
            glBegin(GL_QUADS);
            
            // Front face (blue)
            glColor3f(0.2f, 0.5f, 1.0f);
            glVertex3f(-halfWidth, -halfHeight, halfDepth);
            glVertex3f(halfWidth, -halfHeight, halfDepth);
            glVertex3f(halfWidth, halfHeight, halfDepth);
            glVertex3f(-halfWidth, halfHeight, halfDepth);
            
            // Back face (dark blue)
            glColor3f(0.1f, 0.3f, 0.8f);
            glVertex3f(-halfWidth, -halfHeight, -halfDepth);
            glVertex3f(-halfWidth, halfHeight, -halfDepth);
            glVertex3f(halfWidth, halfHeight, -halfDepth);
            glVertex3f(halfWidth, -halfHeight, -halfDepth);
            
            // Top face (light blue)
            glColor3f(0.3f, 0.6f, 1.0f);
            glVertex3f(-halfWidth, halfHeight, halfDepth);
            glVertex3f(halfWidth, halfHeight, halfDepth);
            glVertex3f(halfWidth, halfHeight, -halfDepth);
            glVertex3f(-halfWidth, halfHeight, -halfDepth);
            
            // Bottom face (medium blue)
            glColor3f(0.15f, 0.4f, 0.9f);
            glVertex3f(-halfWidth, -halfHeight, halfDepth);
            glVertex3f(-halfWidth, -halfHeight, -halfDepth);
            glVertex3f(halfWidth, -halfHeight, -halfDepth);
            glVertex3f(halfWidth, -halfHeight, halfDepth);
            
            // Right face (cyan blue)
            glColor3f(0.25f, 0.55f, 0.95f);
            glVertex3f(halfWidth, -halfHeight, halfDepth);
            glVertex3f(halfWidth, -halfHeight, -halfDepth);
            glVertex3f(halfWidth, halfHeight, -halfDepth);
            glVertex3f(halfWidth, halfHeight, halfDepth);
            
            // Left face (dark cyan)
            glColor3f(0.18f, 0.45f, 0.85f);
            glVertex3f(-halfWidth, -halfHeight, halfDepth);
            glVertex3f(-halfWidth, halfHeight, halfDepth);
            glVertex3f(-halfWidth, halfHeight, -halfDepth);
            glVertex3f(-halfWidth, -halfHeight, -halfDepth);
            
            glEnd();

            // Draw wireframe edges (yellow)
            glBegin(GL_LINES);
            glColor3f(1.0f, 1.0f, 0.0f);
            
            // Front face edges
            glVertex3f(-halfWidth, -halfHeight, halfDepth); glVertex3f(halfWidth, -halfHeight, halfDepth);
            glVertex3f(halfWidth, -halfHeight, halfDepth); glVertex3f(halfWidth, halfHeight, halfDepth);
            glVertex3f(halfWidth, halfHeight, halfDepth); glVertex3f(-halfWidth, halfHeight, halfDepth);
            glVertex3f(-halfWidth, halfHeight, halfDepth); glVertex3f(-halfWidth, -halfHeight, halfDepth);
            
            // Back face edges
            glVertex3f(-halfWidth, -halfHeight, -halfDepth); glVertex3f(halfWidth, -halfHeight, -halfDepth);
            glVertex3f(halfWidth, -halfHeight, -halfDepth); glVertex3f(halfWidth, halfHeight, -halfDepth);
            glVertex3f(halfWidth, halfHeight, -halfDepth); glVertex3f(-halfWidth, halfHeight, -halfDepth);
            glVertex3f(-halfWidth, halfHeight, -halfDepth); glVertex3f(-halfWidth, -halfHeight, -halfDepth);
            
            // Connecting edges
            glVertex3f(-halfWidth, -halfHeight, halfDepth); glVertex3f(-halfWidth, -halfHeight, -halfDepth);
            glVertex3f(halfWidth, -halfHeight, halfDepth); glVertex3f(halfWidth, -halfHeight, -halfDepth);
            glVertex3f(halfWidth, halfHeight, halfDepth); glVertex3f(halfWidth, halfHeight, -halfDepth);
            glVertex3f(-halfWidth, halfHeight, halfDepth); glVertex3f(-halfWidth, halfHeight, -halfDepth);
            
            glEnd();

            glPopMatrix();
        }

        // Swap buffers
        return SwapBuffers(window.getHDC());
    }

} // namespace ParteeEngine